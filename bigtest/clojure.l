(seed (in "/dev/urandom" (rd 8)))
(de rnd- NIL
   (let Big (| (rand 0 7) (>> -28 (rand 0 15)) (>> -57 (rand 0 7)))
      (when (rand T)
         (setq Big (| Big `(hex "1FFFFFF0FFFFFF8"))) )
      (do (rand 0 2)
         (let Dig (| (rand 0 7) (>> -30 (rand 0 15)) (>> -61 (rand 0 7)))
            (when (rand T)
               (setq Dig (| Dig `(hex "1FFFFFFC3FFFFFF8"))) )
            (setq Big (| Dig (>> -64 Big))) ) )
      (if (rand T) Big (- Big)) ) )
(de rnd NIL
   (let B
      (format
         (make
            (do (rand 24000 32000)
               (link (rand 0 9)) ) ) )
      (if (rand T) B (- B)) ) )
(de testme @
   (let (N (readNum)  X (eval (rest)))
      #(println N X (rest))
      (unless (= N X)
         (println 'FAIL 'N: N 'X: X 'rest: (rest))
         (bye) ) ) )
(de op (A B C)
   (prinl "(" A " " B " " C ")") )
(de readNum NIL
   (let N (prog (read) (chop (read)))
      (if (= "N" (last N))
         (format (head -1 N))
         (format N) ) ) )
(de modulo (X Y)
   (% (+ Y (% X Y)) Y) )
(pipe
   (out '(clojure)
      (do 1000
         (setq N1 (pack (rnd) 'N))
         (while (=0 (setq N2 (rnd))))
         (setq N2 (pack N2 'N))
         (prinl N1)
         (prinl N2)
         (op "+" N1 N2)
         (op "-" N1 N2)
         (op "*" N1 N2)
         (op "quot" N1 N2)
         (op "mod" N1 N2)
         (at (0 . 1000) (wait 50)) ) )
   (line)
   (do 10
      (do 100
         (setq N1 (readNum)  N2 (readNum))
         (testme '+ N1 N2)
         (testme '- N1 N2)
         (testme '* N1 N2)
         (testme '/ N1 N2)
         (testme 'modulo N1 N2) )
      (prin ".")
      (flush) ) )
(prinl)
(msg 'OK-clojure)
(bye)
